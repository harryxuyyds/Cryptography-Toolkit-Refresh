using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Runtime.InteropServices.WindowsRuntime;
using Cryptography_Toolkit.Components;
using Cryptography_Toolkit.Helpers;
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using Microsoft.UI.Xaml.Controls.Primitives;
using Microsoft.UI.Xaml.Data;
using Microsoft.UI.Xaml.Input;
using Microsoft.UI.Xaml.Media;
using Microsoft.UI.Xaml.Navigation;
using Windows.Foundation;
using Windows.Foundation.Collections;

// To learn more about WinUI, the WinUI project structure,
// and more about our project templates, see: http://aka.ms/winui-project-info.

namespace Cryptography_Toolkit.Pages;

/// <summary>
/// An empty page that can be used on its own or navigated to within a Frame.
/// </summary>
public sealed partial class AttacksDLPPage : Page
{
    public AttacksDLPPage()
    {
        InitializeComponent();
    }

    private void BabyStepGiantStepExecuteButton_OnClick(object sender, RoutedEventArgs e)
    {
        var shanksBabyStepGiantStepMethod = new Components.ShanksBabyStepGiantStepMethod();
        if (int.TryParse(BabyStepGiantStepOrderNumberBox.Text, out var order) &&
            int.TryParse(BabyStepGiantStepGeneratorNumberBox.Text, out var generator) &&
            int.TryParse(BabyStepGiantStepGroupElementNumberBox.Text, out var groupElement))
        {
            var attacksDlpHelper = new Helpers.AttacksDLPHelper();
            var preCheck = attacksDlpHelper.AttacksDLPMethodPreCheck(generator, groupElement, order);
            if (preCheck == 1)
            {
                BabyStepGiantStepLogTextBox.Text = "Basic BSGS requires prime n";
                BabyStepGiantStepStatusInfoBar.Severity = InfoBarSeverity.Error;
                BabyStepGiantStepStatusInfoBar.Message = "Please enter correct parameters.";
            }
            else if (preCheck == 2)
            {
                BabyStepGiantStepLogTextBox.Text = "Generator α and order n must be coprime ( gcd(α,n)=1 ).";
                BabyStepGiantStepStatusInfoBar.Severity = InfoBarSeverity.Error;
                BabyStepGiantStepStatusInfoBar.Message = "Please enter correct parameters.";
            }
            else if (preCheck == 3)
            {
                BabyStepGiantStepLogTextBox.Text = "Group Element β must be in the cyclic subgroup generated by generator α";
                BabyStepGiantStepStatusInfoBar.Severity = InfoBarSeverity.Error;
                BabyStepGiantStepStatusInfoBar.Message = "Please enter correct parameters.";
            }
            else
            {
                var result = shanksBabyStepGiantStepMethod.ShanksBabyStepGiantStepMethodRun(generator, groupElement, order);
                var log = new System.Text.StringBuilder();

                log.AppendLine("=============== Baby Steps & Giant Steps ===============");
                log.AppendLine($"{"x_b",6} | {"α^x_b mod n",15} || {"i",6} | {"β * α^(-i·t) mod n",20}");
                log.AppendLine(new string('-', 25) + "||" + new string('-', 30));

                int babyCount = result.BabySteps.Count;
                int giantCount = result.GiantSteps.Count;
                int maxRows = Math.Max(babyCount, giantCount);

                for (int row = 0; row < maxRows; row++)
                {
                    string left = row < babyCount
                        ? $"{result.BabySteps[row].Item1,6} | {result.BabySteps[row].Item2,15}"
                        : new string(' ', 6) + " | " + new string(' ', 15);
                    string right = row < giantCount
                        ? $"{result.GiantSteps[row].Item1,6} | {result.GiantSteps[row].Item2,20}"
                        : new string(' ', 6) + " | " + new string(' ', 20);
                    log.AppendLine($"{left} || {right}");
                }
                log.AppendLine();

                log.AppendLine($"Generator Inverse: {result.GeneratorInverse}");
                log.AppendLine($"t (⌈√n⌉): {result.T}");
                log.AppendLine(new string('=', 60));
                if (result.DiscreteLog.HasValue)
                {
                    log.AppendLine($"Discrete Log x: {result.DiscreteLog.Value}");
                    BabyStepGiantStepStatusInfoBar.Severity = InfoBarSeverity.Success;
                    BabyStepGiantStepStatusInfoBar.Message = $"Computation successful. Discrete Log x = {result.DiscreteLog.Value}";
                }
                else
                    log.AppendLine("Discrete Log x: no solution found.");

                BabyStepGiantStepLogTextBox.Text = log.ToString();
            }
        }
        else
        {
            BabyStepGiantStepLogTextBox.Text = "Please enter correct parameters.";
            BabyStepGiantStepStatusInfoBar.Severity = InfoBarSeverity.Warning;
            BabyStepGiantStepStatusInfoBar.Message = "Please enter correct parameters.";
        }
    }

    private void PollardRhoExecuteButton_OnClick(object sender, RoutedEventArgs e)
    {
        var pollardRhoMethod = new Components.PollardRhoMethod();
        if (int.TryParse(PollardRhoOrderNumberBox.Text, out var order) &&
            int.TryParse(PollardRhoGeneratorNumberBox.Text, out var generator) &&
            int.TryParse(PollardRhoGroupElementNumberBox.Text, out var groupElement))
        {
            var attacksDlpHelper = new Helpers.AttacksDLPHelper();
            var preCheck = attacksDlpHelper.AttacksDLPMethodPreCheck(generator, groupElement, order);
            if (preCheck == 1)
            {
                PollardRhoLogTextBox.Text = "Basic Pollard Rho requires prime n";
                PollardRhoStatusInfoBar.Severity = InfoBarSeverity.Error;
                PollardRhoStatusInfoBar.Message = "Please enter correct parameters.";
            }
            else if (preCheck == 2)
            {
                PollardRhoLogTextBox.Text = "Generator α and order n must be coprime ( gcd(α,n)=1 ).";
                PollardRhoStatusInfoBar.Severity = InfoBarSeverity.Error;
                PollardRhoStatusInfoBar.Message = "Please enter correct parameters.";
            }
            else if (preCheck == 3)
            {
                PollardRhoLogTextBox.Text = "Group Element β must be in the cyclic subgroup generated by generator α";
                PollardRhoStatusInfoBar.Severity = InfoBarSeverity.Error;
                PollardRhoStatusInfoBar.Message = "Please enter correct parameters.";
            }
            else
            {
                var result = pollardRhoMethod.PollardRhoMethodRun(generator, groupElement, order);
                var log = new System.Text.StringBuilder();
                log.AppendLine("=============== Pollard Rho Method Log ===============");
                log.AppendLine($"{"Step",6} | {"a_i",6} | {"b_i",6} | {"Output",8}");
                log.AppendLine(new string('-', 38));
                foreach (var item in result.LogItems)
                {
                    log.AppendLine($"{item.i,6} | {item.ai,6} | {item.bi,6} | {item.outi,8}");
                }

                log.AppendLine(new string('=', 60));
                if (result.Result != -1)
                {
                    log.AppendLine($"Result: {result.Result}");
                    log.AppendLine($"{"A1",-4} = {result.A1,-10} {"B1",-4} = {result.B1,-10}");
                    log.AppendLine($"{"A2",-4} = {result.A2,-10} {"B2",-4} = {result.B2,-10}");
                    PollardRhoStatusInfoBar.Severity = InfoBarSeverity.Success;
                    PollardRhoStatusInfoBar.Message = $"Computation successful. Result x = {result.Result}";
                }
                else
                {
                    log.AppendLine("Result: no solution found.");
                    PollardRhoStatusInfoBar.Severity = InfoBarSeverity.Warning;
                    PollardRhoStatusInfoBar.Message = "No solution found.";
                }
                PollardRhoLogTextBox.Text = log.ToString();
            }
        }
    }
}
